\documentclass[11pt]{article}
\usepackage[bordered]{uni-style}
\usepackage{wrapfig}
\usepackage{capt-of}
\usepackage{multicol}
\usepackage{threeparttable} % Required for the threeparttable environment
\usepackage{booktabs} % Required for the \toprule, \midrule, and \bottomrule commands
\usepackage{multirow} % Required for the \multirow command
\title{ساختار کامپیوتر و میکروپروسسور}
\prof{دکتر باقری شورکی}
\subtitle{طراحی یک میکروپروفسور}
\subject{پروژه ترم}
\department{مهندسی برق}
\info{
    \begin{tabular}{rl}
        برنا خدابنده & 400109898\\
    \end{tabular}
}
\date{\today}
\usepackage{xepersian}
\settextfont{Yas}

\begin{document}
\maketitlepage
\maketitlestart

\section{تعریف پروژه}

به دنبال طراحی دستگاهی هستیم که به طور خلاصه، شبیه ساز یک
پردازنده، داخل یک پردازنده، است. چنین دستگاهی وظیفه دارد تا
به صورت \lr{Real-time} \textbf{برنامه نویسی} شود. و همینطور در
اتمام برنامه، برنامه نوشته شده را اجرا نیز کند، بدین صورت که داخل
پردازش خود، باید مراحلی که یک پردازنده طی میکند اعم از
\lr{Fetch, Decode, Execute} را داخل خود شبیه سازی کند، ولی این
کار باید کاملا نرم افزاری باشد یعنی در عمل سخت افزار یک پردازنده را
به صورت نرم افزاری باید شبیه سازی کنیم.

طراحی چنین ماشینی در عمل انجام شدنی است زیرا تمامی مراحل طی شده
اعم از اجرا کد و نوشته شدن کد، یک مسئله تشخیص پذیر است و میتوان آن را
به صورت یک \lr{Finite State Machine} پیاده سازی کرد.

\subsection{توصیف عملکرد}

\textbf{فرایند برنامه نویسی : }
این فرایند در واقع فقط نیاز دارد تا در آدرس های حافظه دلخواه، داده دلخواه توسط کاربر وارد
و ذخیره شود، این اطلاعات میتوانند هم به صورت \lr{OPCODE} و هم به صورت \lr{OPERAND} باشند،
برای پردازنده ما تفاوتی وجود ندارد.

روند برنامه نوشتن به شکل زیر است.

\begin{enumerate}
	\item دکمه \lr{ORG} زده میشود.
	\item یک عدد 2 رقمی به عنوان آدرس وارد میشود.
	\item دکمه \lr{EXE} برای تایید زده میشود.
	\item در این آدرس عددی 2 رقمی به عنوان \lr{OPCODE} یا \lr{OPERAND} قرار داده میشود.
	\item دکمه \lr{EXE} برای تایید زده میشود.
	\item با کلید های + یا - و یا دوباره با ORG به آدرس جدید میرویم.
\end{enumerate}

\clearpage

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{result/schematics.png}
	\caption{شماتیک طرح}
\end{figure}

\section{چالش ها}


\begin{table}[ht]
	\centering
	\begin{threeparttable}
		\caption{آدرس‌ها}
		\label{tbl:addresses}

		\begin{tabular}{lcr}
			\toprule
			\multicolumn{1}{c}{\textbf{حالت کدنویسی}} & \multicolumn{1}{c}{\textbf{آدرس‌ها}} & \multicolumn{1}{c}{\textbf{آدرس‌ها}} \\
			\midrule
			\multirow{4}{*}{\textbf{در حالت کدنویسی}} &
			\lr{R0}                                   & وضعیت FSM                                                                 \\
			                                          & \lr{R1}                             & ورودی                               \\
			                                          & \lr{R2}                             & داده ورودی                          \\
			                                          & \lr{R3}                             & آدرس ورودی                          \\
			\midrule
			\multirow{4}{*}{\textbf{در حالت اجرا}}    &
			\lr{R6}                                   & آدرس شروع                                                                 \\
			                                          & \lr{R1}                             & PC (شمارنده برنامه)                 \\
			                                          & \lr{R3}                             & پشته                                \\
			                                          & \lr{R4}                             & IR (ثبت دستور)                      \\
			\bottomrule
		\end{tabular}

		\begin{tablenotes}
			\item[] منبع: ایجاد توسط نویسنده.
		\end{tablenotes}

	\end{threeparttable}
\end{table}

\clearpage

\section{تست کاربر}

با استفاده از کد زیر، کار گفته شده را انجام میدهیم.
\begin{latin}
	\begin{verbatim}
		MOV R2, #n   ; Set n to the desired value
		MOV R0, #m   ; Set R1 to the starting address m
		MOV R5, #1   ; Initialize R2 to hold the current number
		LOOP:
		MOV A, R5
		MOV @R0, A   ; Write the current number to the memory location pointed by R1
		
		INC R0       ; Increment the memory address
		INC R5       ; Increment the current number
		
		; Decrement n and repeat the loop if not zero
		DEC R2
		MOV A, R2    
		JNZ LOOP
	\end{verbatim}
\end{latin}

حال فقط کافیست تا که کد بالا را روی میکروپروفسور خود قرار دهیم.

\vfil 

\begin{conclusion}
	در آخر ما موفق به ساخت چنین دستگاهی شدیم، بدین صورت که حال میکروپروفسور ای 
	داریم که هر کد اسمبلی ای که به آن دهیم را میتواند مانند یک پروسسور واقعی ( با یک سری محدودیت بیشتر )
	به صورت \lr{Real-time} اجرا کند و برنامه ریزی شود.

	چالش های زیادی در این پیاده سازی داشتیم، اعم از 
	کد کردن ورودی از صفحه کلید به اپراتور های داخل میکروپروفسور، 
	ذخیره درست اطلاعات، پیاده سازی برنامه ریزی میکروپروفسور به صورت نرم افزاری و با صفحه کلید، توصیف 
	برنامه نویسی به صورت یک FSM, پیاده سازی و آپدیت مناسب این FSM، 
	و در نهایت چالش کمتری ولی چالش برای شبیه سازی سیکل اجرای برنامه در داخل پروسسور.

	این قسمت آخر در واقع محدودیت اصلی ما را ایجاد کرده زیرا بعضی از رجیستر ها 
	صرف رجیستر های داخلی این پروسسور نرم افزاری میشوند، همچنین این پروسسور نرم افزاری 
	دیگر قابلیت تعامل با دنیای خارجی به صورت I/O را ندارد.

	در نهایت با استفاده از حداقل رجیستر های پروسسور، و پیاده سازی مناسب FSM توانستیم 
	سیکل های برنامه نویسی و سیکل اجرا را به صورت نرم افزاری شبیه سازی کنیم و یک 
	میکروپروفسور بسازیم.
\end{conclusion}
\end{document}